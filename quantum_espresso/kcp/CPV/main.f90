!
! Copyright (C) 2002-2005 FPMD-CPV groups
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .

SUBROUTINE cpmain_x(tau, fion, etot)

!  this routine does some initialization, then handles for the main loop
!  for Car-Parrinello dynamics
!  ----------------------------------------------
!  this version features:
!  Parrinello-Rahman dynamics
!  generic k-points calculation
!  Nose' thermostat for ions and electrons
!  velocity rescaling for ions
!  Kleinman-Bylander fully non-local pseudopotentials
!  support for local and s, p and d nonlocality
!  generalized gradient corrections
!  core corrections
!  calculus of polarizability
!  DIIS minimization for electrons
!  ions dynamics with DIIS electronic minimization at each step
!  --------------------------------------------
!
!  input units
!  NDR > 50: system configuration at start (not used if nbeg.LT.0)
!            (generated by a previous run, see NDW below)
!  5       : standard input (may be redirected, see start.F)
!  10      : pseudopotential data (must exist for the program to run)
!
!  output units
!  NDW > 50: system configuration (may be used to restart the program,
!            see NDR above)
!  6       : standard output (may be redirected, see start.F)
!  17      : charge density ( file name CHARGE_DENSITY )
!  18      : Kohn Sham states ( file name KS... )
!  19      : file EMPTY_STATES.WF
!  20      : file STRUCTUR_FACTOR
!  29      : atomic velocities
!  30      : conductivity
!  31      : eigenvalues
!  32      : polarization
!  33      : energies + pressure + volume + msd
!  34      : energies
!  35      : atomic trajectories
!  36      : cell trajectories
!  37      : atomic forces
!  38      : internal stress tensor
!  39      : thermostats energies
!  40      : thermal stress tensor
!  ----------------------------------------------

! ... declare modules
   USE kinds
   USE control_flags, ONLY: nomore, tprnfor, tpre, &
                            isave, iprint, &
                            tfor, thdyn, tsde, tsdp, tsdc, &
                            tortho, iprsta, tprnsfac, tdipole, textfor, &
                            tnosee, tnosep, force_pairing, tconvthrs, convergence_criteria, tionstep, nstepe, &
                            ekin_conv_thr, conv_elec, lneb, tnoseh, &
                            gamma_only, do_wf_cmplx
   USE atoms_type_module, ONLY: atoms_type
   USE cell_base, ONLY: press, wmass, boxdimensions, cell_force, cell_move, gethinv, &
                        cell_update_vel, cell_init
   USE polarization, ONLY: ddipole
   USE energies, ONLY: dft_energy_type, debug_energies
   USE dener, ONLY: dekin6, denl

   USE cp_interfaces, ONLY: printout, print_sfac
   USE cp_interfaces, ONLY: empty_cp
   USE cp_interfaces, ONLY: vofrhos, localisation
   USE cp_interfaces, ONLY: rhoofr
   USE cp_interfaces, ONLY: eigs, ortho, elec_fakekine
   USE cp_interfaces, ONLY: writefile, readfile, strucf, phfacs
   USE cp_interfaces, ONLY: runcp_uspp, runcp_uspp_force_pairing

   USE electrons_module, ONLY: nbsp_emp
   USE check_stop, ONLY: check_stop_now
   USE time_step, ONLY: tps, delt
   USE wave_types
   use wave_base, only: frice
   USE io_global, ONLY: ionode
   USE io_global, ONLY: stdout
   USE input, ONLY: iosys
   USE cell_base, ONLY: cell_kinene, velh
   USE cell_base, ONLY: frich, greash, iforceh, tpiba2
   USE stick_base, ONLY: pstickset
   USE ions_base, ONLY: taui, cdmi, nat, nsp, fricp, pmass, iforce, extfor
   USE sic_module, ONLY: self_interaction, nat_localisation
   USE ions_base, ONLY: if_pos, ind_srt, ions_thermal_stress, ions_vel, ions_kinene
   USE ions_base, ONLY: ions_temp
   USE constants, ONLY: au_ps
   USE electrons_base, ONLY: nupdwn, nspin, f, iupdwn, nbsp
   USE electrons_nose, ONLY: electrons_nosevel, electrons_nose_shiftvar, electrons_noseupd, &
                             vnhe, xnhe0, xnhem, xnhep, qne, ekincw
   USE cell_nose, ONLY: cell_nosevel, cell_noseupd, cell_nose_shiftvar, &
                        vnhh, xnhh0, xnhhm, xnhhp, qnh, temph
   USE cell_base, ONLY: cell_gamma, s_to_r
   USE grid_subroutines, ONLY: realspace_grids_init, realspace_grids_para
   USE uspp, ONLY: vkb, nkb, becsum
   USE cdvan, ONLY: dbec
   !
   USE reciprocal_vectors, ONLY: &
      g, & ! G-vectors square modulus
      ggp, & !
      gx, & ! G-vectors component
      mill_l, & ! G-vectors generators
      gcutw, & ! Wave function cut-off ( units of (2PI/alat)^2 => tpiba2 )
      gcutp, & ! Potentials and Charge density cut-off  ( same units )
      gcuts, & ! Smooth mesh Potentials and Charge density cut-off  ( same units )
      gkcut, & ! Wave function augmented cut-off (take into account all G + k_i , same units)
      ngw, & !
      ngm
   !
   USE recvecs_subroutines, ONLY: recvecs_init
   !
   USE wavefunctions_module, ONLY: & ! electronic wave functions
      c0, & ! c0(:,:)  ! wave functions at time t
      cm, & ! cm(:,:)  ! wave functions at time t-delta t
      cp    ! cp(:,:)  ! wave functions at time t+delta t
   !
   USE grid_dimensions, ONLY: nr1, nr2, nr3
   !
   USE ions_nose, ONLY: ions_nose_shiftvar, vnhp, xnhpp, xnhp0, xnhpm, ions_nosevel, ndega, atm2nhp, &
                        ions_noseupd, qnp, kbt, nhpcl, nhpdim, nhpbeg, nhpend, gkbt2nhp, ekin2nhp
   USE core, ONLY: deallocate_core
   USE local_pseudo, ONLY: deallocate_local_pseudo
   USE printout_base, ONLY: printout_base_init
   USE cp_main_variables, ONLY: ei1, ei2, ei3, eigr, sfac, lambda, &
                                ht0, htm, htp, rhor, vpot, rhog, rhos, wfill, &
                                acc, edft, nfi, bec, becdr, &
                                ema0bg, descla, irb, eigrb, iprint_stdout
   USE ions_positions, ONLY: atoms0, atomsp, atomsm, ions_move, &
                             max_ion_forces, ions_shiftval, resort_position
   USE cg_module, ONLY: tcg
   USE cp_electronic_mass, ONLY: emass, emass_cutoff, emass_precond
   !
   IMPLICIT NONE
   !
   REAL(DP) :: tau(:, :)
   REAL(DP) :: fion(:, :)
   REAL(DP) :: etot

! ... declare functions

! ... declare other variables
   INTEGER  :: nstep_this_run, iunit, is, i

   REAL(DP) :: ekinc, ekcell, ekinp, erhoold, maxfion, ekinpr
   REAL(DP) :: derho
   REAL(DP) :: hgamma(3, 3) = 0.0d0
   REAL(DP) :: temphh(3, 3) = 0.0d0
   REAL(DP) :: fcell(3, 3) = 0.0d0
   REAL(DP) :: newh(3, 3) = 0.0d0
   REAL(DP) :: fion_tot(3) = 0.0d0

   LOGICAL :: ttforce, tstress
   LOGICAL :: ttprint, ttsave, ttdipole, ttexit
   LOGICAL :: tstop, tconv, doions
   LOGICAL :: topen, ttempst
   LOGICAL :: ttconvchk
   LOGICAL :: tstdout

   REAL(DP) :: fccc, ccc, dt2bye, intermed
   REAL(DP) :: temps(nat), tempp
   REAL(DP), DIMENSION(:, :, :), ALLOCATABLE :: lambda_dumb

   LOGICAL :: lgam

   !
   ! ... end of declarations
   !
   lgam = gamma_only .and. .not. do_wf_cmplx
   !
   erhoold = 1.0d+20  ! a very large number
   ekinc = 0.0_DP
   ekcell = 0.0_DP
   fccc = 1.0d0
   nstep_this_run = 0

   IF (tcg) &
      CALL errore(' fpmd ', ' CG not allowed, use CP instead ', 1)

   ttexit = .FALSE.

   MAIN_LOOP: DO

      call start_clock('main_loop')

      ! ...   increment simulation steps counter
      !
      nfi = nfi + 1

      ! ...   increment run steps counter
      !
      nstep_this_run = nstep_this_run + 1

      ! ...   Increment the integral time of the simulation
      !
      tps = tps + delt*au_ps

      ! ...   set the right flags for the current MD step
      !
      ttprint = (MOD(nfi, iprint) == 0) .OR. (iprsta > 2) .OR. ttexit
      tstdout = (MOD(nfi, iprint_stdout) == 0) .OR. (iprsta > 2) .OR. ttexit
      !
      ttsave = MOD(nfi, isave) == 0
      !
      ttconvchk = tconvthrs%active .AND. (MOD(nfi, tconvthrs%nstep) == 0)
      !
      ttdipole = ttprint .AND. tdipole
      ttforce = tfor .OR. (ttprint .AND. tprnfor)
      tstress = thdyn .OR. (ttprint .AND. tpre)
      ttempst = ttprint .AND. (nbsp_emp > 0)
      doions = .TRUE.

      IF (ionode .AND. tstdout) THEN
         !
         WRITE (stdout, fmt='( /, " * Physical Quantities at step:",  I6 )') nfi
         WRITE (stdout, fmt='( /, "   Simulated time t = ", D15.8, " ps" )') tps
         !
      END IF

      IF (tnosee) THEN
         fccc = 1.0d0/(1.0d0 + vnhe*delt*0.5d0)
      ELSE IF (tsde) THEN
         fccc = 1.0d0
      ELSE
         fccc = 1.0d0/(1.0d0 + frice)
      END IF

      !
      ! ...     calculate thermostat velocity
      !

      IF (tfor .AND. tnosep .AND. doions) THEN
         !
         ! ...     Determines D(Xnos)/DT dynamically
         !
         CALL ions_nosevel(vnhp, xnhp0, xnhpm, delt, nhpcl, nhpdim)
         !
      END IF

      IF (tnosee) THEN
         !
         call electrons_nosevel(vnhe, xnhe0, xnhem, delt)
         !
      END IF

      IF (thdyn .AND. tnoseh) THEN
         !
         CALL cell_nosevel(vnhh, xnhh0, xnhhm, delt)
         !
         velh(:, :) = 2.d0*(ht0%hmat(:, :) - htm%hmat(:, :))/delt - velh(:, :)
         !
      END IF

      IF (thdyn) THEN
         !
         ! ...     the simulation cell isn't fixed, recompute the reciprocal lattice
         !
         CALL newinit(ht0%hmat)
         !
         CALL newnlinit()
         !
         CALL emass_precond(ema0bg, ggp, ngw, tpiba2, emass_cutoff)
         !
      END IF

      IF (tfor .OR. thdyn) THEN
         !
         ! ...     ionic positions aren't fixed, recompute structure factors
         !
         CALL phfacs(ei1, ei2, ei3, eigr, mill_l, atoms0%taus, nr1, nr2, nr3, atoms0%nat)
         !
         CALL strucf(sfac, ei1, ei2, ei3, mill_l, ngm)
         !
         CALL prefor(eigr, vkb)
         !
      END IF

      IF (thdyn) THEN
         !
         !      the simulation cell isn't fixed, recompute local
         !      pseudopotential Fourier expansion
         !
         CALL formf(.false., edft%eself)
         !
      END IF

      ! ...
      !
      CALL calbec(1, nsp, eigr, c0, bec)
      !
      IF (tstress) THEN
         !
         CALL caldbec(ngw, nkb, nbsp, 1, nsp, eigr, c0, dbec)
         !
      END IF

      atoms0%for = 0.0d0
      !
      IF (ttforce .OR. thdyn) THEN
         !
         call nlfq(c0, eigr, bec, becdr, atoms0%for, lgam)
         !
      END IF
      !
      ! ...   compute the new charge density "rhor"
      !
      CALL rhoofr(nfi, c0, irb, eigrb, bec, becsum, rhor, rhog, rhos, edft%enl, denl, edft%ekin, dekin6, tstress)
      !
      ! ...   vofrhos compute the new DFT potential "vpot", and energies "edft",
      ! ...   ionc forces "fion" and stress "paiu".
      !
      CALL vofrhos(ttprint, ttforce, tstress, rhor, rhog, atoms0, &
                   vpot, bec%rvec, c0, f, eigr, ei1, ei2, ei3, sfac, ht0, edft)

      ! CALL debug_energies( edft ) ! DEBUG

      ! ...   Car-Parrinello dynamics for the electrons
      !
      !    move electronic degrees of freedom by Verlet's algorithm
      !    on input, c0 are the wave functions at time "t" , cm at time "t-dt"
      !    on output cp are the new wave functions at time "t+dt"
      !
      dt2bye = delt*delt/emass
      !
      cp = cm
      !
      ! write(6,*) 'ema0bg=', ema0bg(1), ema0bg( SIZE(ema0bg)/2 )  ! debug
      ! write(6,*) 'alat=', alat ! debug
      !
      if (force_pairing) then
         !
         ! unpaired electron is assumed of spinup and in highest
         ! index band; and put equal for paired wf spin up and down
         !
         CALL runcp_uspp_force_pairing(fccc, ccc, ema0bg, dt2bye, vpot, bec%rvec, c0, cp, intermed)
         !
      ELSE
         !
         CALL runcp_uspp(nfi, fccc, ccc, ema0bg, dt2bye, vpot, bec, c0, cp)
         !
      END IF
      !
      !  Orthogonalize the new wave functions "cp"

      IF (tortho) THEN
         !
         ccc = fccc*dt2bye
         !
         CALL ortho(c0, cp, lambda, descla, ccc, nupdwn, iupdwn, nspin)
         !
         IF (ttprint) CALL eigs(nfi, lambda, lambda)
         !
      ELSE
         DO is = 1, nspin
            CALL gram(vkb, bec, nkb, cp(1, iupdwn(is)), SIZE(cp, 1), nupdwn(is))
         END DO
      END IF

      !  Compute fictitious kinetic energy of the electrons at time t

      ekinc = 0

      CALL elec_fakekine(ekinc, ema0bg, emass, cp, cm, ngw, nbsp, 1, 2.0d0*delt)

      !
      !  check if ions should be moved
      !
      IF (tfor .AND. tionstep) THEN
         !
         doions = .FALSE.
         IF ((ekinc < ekin_conv_thr) .AND. (MOD(nfi, nstepe) == 0)) THEN
            doions = .TRUE.
         END IF
         !
         WRITE (stdout, fmt="(3X,'MAIN: doions = ',L1)") doions
         !
      END IF
      !

      IF (tfor .AND. doions) THEN
         !
         !   Add thermal stress to paiu
         !
         CALL ions_thermal_stress(ht0%paiu, atoms0%m, 1.0d0, ht0%hmat, atoms0%vels, atoms0%nsp, atoms0%na)
         !
      END IF

      ! ...   Cell Dynamics

      ekcell = 0.0d0  ! kinetic energy of the cell (Parrinello-Rahman scheme)

      hgamma = 0.0d0

      IF (thdyn .AND. doions) THEN

         !   move cell coefficients
         !
         CALL cell_force(fcell, ht0%hinv, ht0%paiu, 1.0d0, press, wmass)

         CALL cell_move(newh, ht0%hmat, htm%hmat, delt, &
                        iforceh, fcell, frich, tnoseh, vnhh, velh, tsdc)

         CALL cell_init('n', htp, newh)
         !
         CALL cell_update_vel(htp, ht0, htm, delt, velh)

         CALL cell_gamma(hgamma, ht0%hinv, ht0%hmat, velh)

         !   Kinetic energy of the box

         CALL cell_kinene(ekcell, temphh, velh)

      END IF

      !
      ! ...   Ions Dynamics
      !
      ekinp = 0.d0  ! kinetic energy of ions
      !
      IF (tfor .AND. doions) THEN
         !
         IF (textfor) FORALL (i=1:nat) fion(:, i) = fion(:, i) + extfor(:, i)
         !
         fion_tot(:) = SUM(fion(:, :), DIM=2)/DBLE(nat)
         !
         FORALL (i=1:nat) fion(:, i) = fion(:, i) - fion_tot(:)
         !
         ! ...     move ionic degrees of freedom
         !
         CALL ions_move(atomsp%taus, atoms0%taus, atomsm%taus, iforce, pmass, atoms0%for, ht0%hinv, &
                        delt, atoms0%na, atoms0%nsp, fricp, hgamma, atoms0%vels, tsdp, tnosep, &
                        atomsm%for, vnhp, atomsp%vels, atomsm%vels, nhpcl, nhpdim, atm2nhp)
         !
         CALL s_to_r(atomsp%taus, atomsp%taur, atomsp%na, atomsp%nsp, htp%hmat)
         !
      END IF

      ekinpr = 0.0d0

      IF (tfor .AND. doions) THEN
         !
         CALL ions_vel(atoms0%vels, atomsp%taus, atomsm%taus, atoms0%na, atoms0%nsp, delt)
         !
         CALL ions_kinene(ekinp, atoms0%vels, atoms0%na, atoms0%nsp, ht0%hmat, pmass)
         !
         atoms0%ekint = ekinp
         !
         CALL ions_temp(tempp, temps, ekinpr, atoms0%vels, atoms0%na, atoms0%nsp, &
                        ht0%hmat, atoms0%m, ndega, nhpdim, atm2nhp, ekin2nhp)
         !
      END IF
      !
      !
      ! ... udating nose-hoover friction variables
      !
      !
      IF (tnosep) THEN
         !
         ! below one really should have atoms0%ekint and NOT ekin2nhp
         CALL ions_noseupd(xnhpp, xnhp0, xnhpm, delt, qnp, ekin2nhp, gkbt2nhp, vnhp, kbt, nhpcl, nhpdim, nhpbeg, nhpend)
         !
      END IF
      !
      IF (tnoseh) THEN
         CALL cell_noseupd(xnhhp, xnhh0, xnhhm, delt, qnh, temphh, temph, vnhh)
      END IF
      !
      IF (tnosee) THEN
         CALL electrons_noseupd(xnhep, xnhe0, xnhem, delt, qne, ekinc, ekincw, vnhe)
      END IF
      !

      call stop_clock('main_loop')

      ! ...   Here find Empty states eigenfunctions and eigenvalues
      !
      IF (ttempst) THEN
         CALL empty_cp(nfi, c0, vpot)
      END IF

      ! ...   dipole
      !
      IF (ttdipole) THEN

         IF (wfill%nspin > 1) &
            CALL errore(' main ', ' dipole with spin not yet implemented ', 0)
         !
         CALL ddipole(nfi, c0, ngw, atoms0%taus, tfor, ngw, wfill%nbl(1), ht0%a)

      END IF

      IF (self_interaction /= 0) THEN
         IF (nat_localisation > 0 .AND. ttprint) THEN
            CALL localisation(cp(:, nupdwn(1)), atoms0, ht0)
         END IF
      END IF

      ! ...   if we are going to check convergence, then compute the
      ! ...   maximum value of the ionic forces

      tconv = .FALSE.
      !
      IF (ttconvchk) THEN
         !
         IF (ttforce) THEN
            maxfion = max_ion_forces(atoms0)
         ELSE
            maxfion = 0.0d0
         END IF
         !
         derho = (erhoold - edft%etot)
         tconv = (derho < tconvthrs%derho)
         tconv = tconv .AND. (ekinc < tconvthrs%ekin)
         !
         IF (.NOT. lneb) THEN
            tconv = tconv .AND. (maxfion < tconvthrs%force)
         END IF
         !
         IF (ionode) THEN
            !
            IF (tstdout .OR. tconv) THEN
               !
               WRITE (stdout, fmt= &
                      "(/,3X,'MAIN:',10X,'EKINC   (thr)',10X,'DETOT   (thr)',7X,'MAXFORCE   (thr)')")
               !
               WRITE (stdout, fmt="(3X,'MAIN: ',3(D14.6,1X,D8.1))") &
                  ekinc, tconvthrs%ekin, derho, tconvthrs%derho, maxfion, tconvthrs%force
               !
               IF (tconv) THEN
                  WRITE (stdout, fmt="(3X,'MAIN: convergence achieved for system relaxation',/)")
               ELSE
                  WRITE (stdout, fmt="(3X,'MAIN: convergence NOT achieved for system relaxation',/)")
               END IF
               !
            END IF
            !
         END IF
         !
         erhoold = edft%etot
         !
      END IF

      ! ...   printout
      !

      CALL printout(nfi, atoms0, ekinc, ekcell, ttprint, ht0, edft)

      ! ...   Update variables

      !
      CALL electrons_shiftval(cm, c0, cp)
      !
      IF (tnosee) THEN
         CALL electrons_nose_shiftvar(xnhep, xnhe0, xnhem)
      END IF

      IF (doions) THEN

         IF (tfor) THEN
            !
            CALL ions_shiftval(atomsm, atoms0, atomsp)
            !
            IF (tnosep) THEN
               CALL ions_nose_shiftvar(xnhpp, xnhp0, xnhpm)
            END IF
            !
         END IF

         IF (thdyn) THEN
            !
            CALL cell_shiftval(htm, ht0, htp)
            !
            IF (tnoseh) THEN
               CALL cell_nose_shiftvar(xnhhp, xnhh0, xnhhm)
            END IF
            !
         END IF

      END IF

      frich = frich*greash

      ! ...   stop the code if either the file .cp_stop is present or if
      ! ...   the cpu time exceeds the limit set in input (max_seconds)

      tstop = check_stop_now()

      tstop = tstop .OR. tconv .OR. (nfi >= nomore)
      !
      !
      tstop = tstop .OR. ttexit
      !

      IF (tstop) THEN
         !
         ! ... all condition to stop the code are satisfied
         !
         IF (ttprint) THEN
            !
            ! ...   we are in a step where printing is active,
            ! ...   exit immediately
            !
            ttexit = .TRUE.
            !
         ELSE IF (.NOT. ttexit) THEN
            !
            ! ...   perform an additional step, in order to compute
            ! ...   quantity to print out
            !
            ttexit = .TRUE.
            !
            CYCLE MAIN_LOOP
            !
         END IF
         !
      END IF
      !
      ! ...   write the restart file
      !
      IF (ttsave .OR. ttexit) THEN
         CALL writefile(nfi, tps, c0, cm, f, atoms0, atomsm, acc, &
                        taui, cdmi, htm, ht0, rhor, lambda_dumb, ttexit) !modified:giovanni
      END IF

      ! ...   loop back
      !
      IF (ttexit) EXIT MAIN_LOOP

   END DO MAIN_LOOP

   conv_elec = tconv .OR. ttexit
   etot = edft%etot
   !
   CALL resort_position(tau, fion, atoms0, ind_srt, ht0)
   !
   IF (lneb) THEN
      DO i = 1, nat
         fion(:, i) = fion(:, i)*DBLE(if_pos(:, i))
      END DO
   END IF
   !
   IF (tprnsfac) THEN
      CALL print_sfac(rhor, sfac)
   END IF

   DO iunit = 10, 99
      IF (iunit == stdout) CYCLE
      INQUIRE (UNIT=iunit, OPENED=topen)
      IF (topen) THEN
         WRITE (stdout, *) '  main: Closing unit :', iunit
         CLOSE (iunit)
      END IF
   END DO

   RETURN

CONTAINS

   SUBROUTINE cell_shiftval(box_tm1, box_t0, box_tp1)
      type(boxdimensions) :: box_tm1, box_t0, box_tp1
      box_tm1 = box_t0
      box_t0 = box_tp1
      RETURN
   END SUBROUTINE cell_shiftval

   SUBROUTINE electrons_shiftval(cm, c0, cp)
      USE kinds, ONLY: DP
      IMPLICIT NONE
      COMPLEX(DP), INTENT(IN)    :: cp(:, :)
      COMPLEX(DP), INTENT(INOUT) :: c0(:, :)
      COMPLEX(DP), INTENT(OUT)   :: cm(:, :)
      cm(:, :) = c0(:, :)
      c0(:, :) = cp(:, :)
      RETURN
   END SUBROUTINE electrons_shiftval

END SUBROUTINE cpmain_x
