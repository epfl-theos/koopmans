<table id="uiTable" style="width:100%; text-align:left">
   <tr>
      <th>Keyword</th>
      <th>Description</th>
      <th>Type</th>
      <th>Default</th>
   </tr>
   <tr>
      <td><code>kc_ham_file</code></td>
      <td>the name of the Hamiltonian file to read in</td>
      <td><code>Path</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>w90_seedname</code></td>
      <td>w90_seedname must be equal to the seedname used in the previous Wannier90 calculation. The code will look for a file called w90_seedname.wout</td>
      <td><code>Path</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>w90_calc</code></td>
      <td>Specifies the type of PW/Wannier90 calculation preceding the koopmans calculation. If the latter is done in a supercell at Gamma then w90_calc must be equal to 'sc', otherwise if it comes from a calculation with k-points it must be equal to 'pc'.
</td>
      <td><code>str</code></td>
      <td><code>pc</code> (must be <code>pc</code>/<code>sc</code>)</td>
   </tr>
   <tr>
      <td><code>do_map</code></td>
      <td>if True, it realizes the map |m&gt; --&gt; |Rn&gt;, that connects the Wannier functions in the supercell to those in the primitive cell. This is basically the unfolding procedure. It can be activated only if w90_calc='sc'</td>
      <td><code>bool</code></td>
      <td><code>False</code></td>
   </tr>
   <tr>
      <td><code>use_ws_distance</code></td>
      <td>if True, the real Wigner-Seitz distance between the Wannier functions centers is considered as in the Wannier90 code. In particular, this accounts for the periodic boundary conditions and it is crucial for a good interpolation when using coarse MP meshes or, equivalently, small supercells</td>
      <td><code>bool</code></td>
      <td><code>True</code></td>
   </tr>
   <tr>
      <td><code>kpath</code></td>
      <td>path in the Brillouin zone for generating the band structure, specified by a string e.g. "GXG"</td>
      <td><code>str</code>/<code>BandPath</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>smooth_int_factor</code></td>
      <td>if this is &gt; 1 (or is a 3-element list with at least one entry &gt; 1), the smooth interpolation method is used. This consists of removing the DFT part of the Hamiltonian from the full Koopmans Hamiltonian and adding the DFT Hamiltonian from a calculation with a denser k-points mesh, where this keyword defines how many times denser to make the mesh. (If this is set to a scalar a, the new k-grid will be [a*kx_old, a*ky_old, a*kz_old]. If it is a list [a, b, c], the dense k-grid will be [a*kx_old, b*ky_old, c*kz_old].) This works only for a non self-consistent Koopmans calculation using Wannier since, to be consistent, all the Hamiltonians must be in the same gauge, i.e. the Wannier gauge</td>
      <td><code>int</code>/<code>list</code>/<code>ndarray</code></td>
      <td><code>[1, 1, 1]</code></td>
   </tr>
   <tr>
      <td><code>dft_ham_file</code></td>
      <td></td>
      <td><code>Path</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>dft_smooth_ham_file</code></td>
      <td></td>
      <td><code>Path</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>do_dos</code></td>
      <td>if True, the density-of-states is interpolated along the input kpath. The DOS is written to a file called "dos_interpolated.dat"</td>
      <td><code>bool</code></td>
      <td><code>True</code></td>
   </tr>
</table>