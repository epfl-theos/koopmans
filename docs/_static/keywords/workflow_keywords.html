<table id="workflowTable" style="width:100%; text-align:left">
   <tr>
      <th>Keyword</th>
      <th>Description</th>
      <th>Type</th>
      <th>Default</th>
   </tr>
   <tr>
      <td><code>task</code></td>
      <td>Task to perform</td>
      <td><code>str</code></td>
      <td><code>singlepoint</code> (must be <code>singlepoint</code>/<code>convergence</code>/<code>wannierize</code>/<code>environ_dscf</code>/<code>ui</code>/<code>dft_bands</code>/<code>dft_eps</code>/<code>trajectory</code>/<code>convergence_ml</code>)</td>
   </tr>
   <tr>
      <td><code>functional</code></td>
      <td>orbital-density-dependent-functional/density-functional to use</td>
      <td><code>str</code></td>
      <td><code>ki</code> (must be <code>ki</code>/<code>kipz</code>/<code>pkipz</code>/<code>dft</code>/<code>all</code>)</td>
   </tr>
   <tr>
      <td><code>base_functional</code></td>
      <td>base functional to use</td>
      <td><code>str</code></td>
      <td><code>pbe</code> (must be <code>lda</code>/<code>pbe</code>/<code>pbesol</code>)</td>
   </tr>
   <tr>
      <td><code>calculate_alpha</code></td>
      <td>whether or not to calculate the screening parameters ab-initio</td>
      <td><code>bool</code></td>
      <td><code>True</code></td>
   </tr>
   <tr>
      <td><code>pseudo_library</code></td>
      <td>the pseudopotential library to use (valid options depend on the value of base_functional)</td>
      <td><code>str</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>pseudo_directory</code></td>
      <td>the folder containing the pseudopotentials to use (mutually exclusive with "pseudo_library")</td>
      <td><code>Path</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>method</code></td>
      <td>the method to calculate the screening parameters: either with Î”SCF or DFPT</td>
      <td><code>str</code></td>
      <td><code>dscf</code> (must be <code>dscf</code>/<code>dfpt</code>)</td>
   </tr>
   <tr>
      <td><code>init_orbitals</code></td>
      <td>which orbitals to use as an initial guess for the variational orbitals</td>
      <td><code>str</code></td>
      <td><code>pz</code> (must be <code>pz</code>/<code>kohn-sham</code>/<code>mlwfs</code>/<code>projwfs</code>)</td>
   </tr>
   <tr>
      <td><code>init_empty_orbitals</code></td>
      <td>which orbitals to use as an initial guess for the empty variational orbitals (defaults to the same value as "init_orbitals")</td>
      <td><code>str</code></td>
      <td><code>same</code> (must be <code>same</code>/<code>pz</code>/<code>kohn-sham</code>/<code>mlwfs</code>/<code>projwfs</code>)</td>
   </tr>
   <tr>
      <td><code>frozen_orbitals</code></td>
      <td>if True, freeze the variational orbitals for the duration of the calculation once they've been initialized</td>
      <td><code>bool</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>calculate_bands</code></td>
      <td>whether or not to calculate the band structure of the system (if relevant)</td>
      <td><code>bool</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>spin_polarized</code></td>
      <td>if True, the system will be allowed to break spin symmetry i.e. n^{up}(r) != n^{down}(r)</td>
      <td><code>bool</code></td>
      <td><code>False</code></td>
   </tr>
   <tr>
      <td><code>fix_spin_contamination</code></td>
      <td>if True, steps will be taken to try and avoid spin contamination. This is only sensible when performing a non-spin-polarized calculation, and is turned on by default for such calculations</td>
      <td><code>bool</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>npool</code></td>
      <td>Number of pools for parallelizing over kpoints (should be commensurate with the k-point grid)</td>
      <td><code>int</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>gb_correction</code></td>
      <td>if True, apply the Gygi-Baldereschi scheme to deal with the q-&gt;0 divergence of the Coulomb interation for periodic systems</td>
      <td><code>bool</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>mp_correction</code></td>
      <td>if True, apply the Makov-Payne correction for charged periodic systems</td>
      <td><code>bool</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>mt_correction</code></td>
      <td>if True, apply the Martyna-Tuckerman correction for charged aperiodic systems</td>
      <td><code>bool</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>eps_inf</code></td>
      <td>dielectric constant of the system used by the Gygi-Baldereschi and Makov-Payne corrections; either provide an explicit value or set to "auto" to calculate it ab initio</td>
      <td><code>float</code>/<code>str</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>alpha_numsteps</code></td>
      <td>maximum number of self-consistency steps for calculating alpha</td>
      <td><code>int</code></td>
      <td><code>1</code></td>
   </tr>
   <tr>
      <td><code>alpha_conv_thr</code></td>
      <td>convergence threshold for |Delta E_i - epsilon_i|; if below this threshold, the corresponding alpha value is not updated</td>
      <td><code>float</code>/<code>str</code></td>
      <td><code>0.001</code></td>
   </tr>
   <tr>
      <td><code>alpha_guess</code></td>
      <td>starting guess for alpha (overridden if alpha_from_file is true)</td>
      <td><code>float</code>/<code>list</code></td>
      <td><code>0.6</code></td>
   </tr>
   <tr>
      <td><code>alpha_mixing</code></td>
      <td>mixing parameter for updating alpha</td>
      <td><code>float</code></td>
      <td><code>1.0</code></td>
   </tr>
   <tr>
      <td><code>alpha_from_file</code></td>
      <td>if True, uses the file_alpharef.txt from the base directory as a starting guess</td>
      <td><code>bool</code></td>
      <td><code>False</code></td>
   </tr>
   <tr>
      <td><code>from_scratch</code></td>
      <td>if True, will delete any preexisting workflow and start again; if False, will resume a workflow from where it was last up to</td>
      <td><code>bool</code></td>
      <td><code>True</code></td>
   </tr>
   <tr>
      <td><code>keep_tmpdirs</code></td>
      <td>If False, delete all of the temporary directories at the end of the calculation</td>
      <td><code>bool</code></td>
      <td><code>True</code></td>
   </tr>
   <tr>
      <td><code>orbital_groups</code></td>
      <td>a list of integers the same length as the total number of bands, denoting which bands to assign the same screening parameter to</td>
      <td><code>list</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>orbital_groups_self_hartree_tol</code></td>
      <td>when calculating alpha parameters, the code will group orbitals together only if their self-Hartree energy is within this threshold</td>
      <td><code>float</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>orbital_groups_spread_tol</code></td>
      <td>when calculating alpha parameters, the code will group orbitals together only if their spread is within this threshold</td>
      <td><code>float</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>converge</code></td>
      <td>If True, repeat the workflow increasing the convergence_parameters until the convergence_observable converges within the convergence_threshold</td>
      <td><code>bool</code></td>
      <td><code>False</code></td>
   </tr>
   <tr>
      <td><code>dfpt_coarse_grid</code></td>
      <td>The coarse k-point grid on which to perform the DFPT calculations</td>
      <td><code>list</code></td>
      <td></td>
   </tr>
   <tr>
      <td><code>eps_cavity</code></td>
      <td>a list of epsilon_infinity values for the cavity in dscf calculations</td>
      <td><code>list</code></td>
      <td><code>[1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</code></td>
   </tr>
</table>