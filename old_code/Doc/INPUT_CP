Input data format: { } = optional, [ ] = it depends

All quantities whose dimensions are not explicitly specified are in
HARTREE ATOMIC UNITS
BEWARE: TABS, DOS <CR><LF> CHARACTERS ARE POTENTIAL SOURCES OF TROUBLE

===============================================================================
&CONTROL
  ...
/
&SYSTEM
 ...
/
&ELECTRONS
...
/
[ &IONS
  ...
 / ]
[ &CELL
  ...
 / ]
[ &WANNIER
  ...
 / ]
ATOMIC_SPECIES
 X  Mass_X  PseudoPot_X
 Y  Mass_Y  PseudoPot_Y
 Z  Mass_Z  PseudoPot_Z
ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }
in all cases except calculation = 'neb' or 'smd' :
  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
  Y 0.5  0.0  0.0
  Z O.0  0.2  0.2
if calculation = 'neb' .OR. 'smd' :
  first_image
  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
  Y 0.5  0.0  0.0
  Z O.0  0.2  0.2
  { intermediate_image 1
    X 0.0  0.0  0.0
    Y 0.9  0.0  0.0
    Z O.0  0.2  0.2
    intermediate_image ...
    X 0.0  0.0  0.0
    Y 0.9  0.0  0.0
    Z O.0  0.2  0.2 }
  last_image
  X 0.0  0.0  0.0
  Y 0.7  0.0  0.0
  Z O.0  0.5  0.2 
[ CELL_PARAMETERS { cubic | hexagonal }
   a(1,1) a(2,1) a(3,1)
   a(1,2) a(2,2) a(3,2)
   a(1,3) a(2,3) a(3,3) ]
[ OCCUPATIONS
   f_inp(1,1)  f_inp(2,1)  f_inp(3,1) ... f_inp(10,1)
   f_inp(11,1) f_inp(12,1) ... f_inp(nbnd,1)
 [ f_inp(1,2)  f_inp(2,2)  f_inp(3,2) ... f_inp(10,2)
   f_inp(11,2) f_inp(12,2) ... f_inp(nbnd,2) ] ]
[ CLIMBING_IMAGES
   list of images, separated by a comma ]   
[ CONSTRAINTS
   nconstr   { constr_tol }
   constr_type(.)   constr(1,.)   constr(2,.) { constr_target(.) } ]

===============================================================================
NAMELIST &CONTROL

calculation    CHARACTER ( default = 'cp' )
               a string describing the task to be performed:
               'cp', 'scf', 'nscf', 'relax', 'vc-relax', 'vc-cp', 'neb', 
               'smd', 'cp-wf', 'fpmd', 'metadyn'
               where :               
               cp       = Car-Parrinello MD (includes cases 'scf' and 'relax')
               scf      = electron minimization
               nscf     = non-selfconsistent calculation of KS states:
                          reads the charge density previously saved to disk,
                          sets occupancies to a bogus nonzero value
               relax    = ionic minimization
               vc-relax = ionic + cell minimization
               vc-cp    = variable-cell Car-Parrinello (-Rahman) dynamics
               neb      = Nudged Elastc Band method
               smd      = String Method Dynamics
               cp-wf    = Car-Parrinello MD with Wannier functions
               fpmd     = CP works in FPMD compatibility mode, with all FPMD
                          features not yet ported in CP, but works only for
                          norm-conserving pseudopotentials
               metadyn  = Laio-Parrinello meta-dynamics

title          CHARACTER ( default = 'MD Simulation' )
               reprinted on output.

restart_mode   CHARACTER ( default = 'restart' )
               from_scratch    = from scratch
	                         NEB only: the starting path is obtained
                                 with a linear interpolation between the images
                                 specified in the ATOMIC_POSITIONS card.
			         Note that in the linear interpolation
                                 periodic boundary conditions ARE NON USED.
               restart         = continue a previous simulation,
                                 and performs  "nstep" new steps,
               reset_counters  = continue a previous simulation,
                                 performs  "nstep" new steps, resetting
                                 the counter and averages
               upto            = continue a previous simulation and stops 
                                 when the counter value is equal "nstep"

nstep          INTEGER                         
               number of ionic + electronic steps
               default =    1 if calculation = 'scf', 'nscf'
	               =    0 if calculation = 'neb', 'smd'
                       =   50 for the other cases

tstress        LOGICAL ( default = .FALSE. )
               This flag controls the printing of the stress, always .TRUE.
               when the cell is moving.
               .TRUE.    = write the stress tensor to standard output 
                           every "iprint" steps.
               .FALSE.   = do not write the stress tensor stdout.

tprnfor        LOGICAL ( default = .FALSE. )
               This flag controls the printing of the interatomic forces, 
               always .TRUE. when the ions are moving.
               .TRUE.    =  write the atomic forces to standard output every 
                            "iprint" steps.
               .FALSE.   =   do not write atomic forces to stdout.

dt             REAL ( default = 1.D0 )
               time step for molecular dynamics, in Hartree atomic units.
               ( 1 a.u. of time = 2.4189 * 10^-17 s )

ekin_conv_thr  REAL ( default = 1.D-6 )
               convergence criterion for electron minimization:
               convergence is achieved when "ekin < ekin_conv_thr".
               See also etot_conv_thr - both criteria must be satisfied.

etot_conv_thr  REAL ( default = 1.D-4 )
               convergence criteria for ion minimization:
               "etot(n+1)-etot(n) < etot_conv_thr", where "n" is the step 
               index, and "etot" the DFT energy.
               See also ekin_conv_thr for electron minimization and 
               forc_conv_thr for ion minimization - both criteria must be 
               satisfied.

forc_conv_thr  REAL ( default = 1.D-3 )
               "MAXVAL(fion) < forc_conv_thr", where fion are the atomic 
               forces.
               See also etot_conv_thr - both criteria must be satisfied.

max_seconds    REAL ( default = 1.D+7 )
               smoothly terminate program after the specified number of seconds
               this parameter is typically used to prevent an hard kill from
               the queuing system.

tefield        LOGICAL ( default = .FALSE.)
               If .TRUE. perform calculations with a finite electric field 
               which is described through the modern theory of the polarization

iprint         INTEGER ( default = 10 )
               Number of steps between successive writings of relevant 
               physical quantities to standard output and to files "fort.3?" 
               or "prefix.???" depending on "prefix" parameter

isave          INTEGER ( default = 100 )
               Number of steps between successive savings of
               information needed to restart the run ( see also ndr, ndw ).

prefix         CHARACTER ( default = 'cp' )
               basename prepended to input/output filenames. 
               
verbosity      CHARACTER
               'high' | 'default' | 'low' | 'minimal' | 'default+projwfc'
               'default+projwfc' 
                  the codes prints the dafault output quantities
                  and the projections of the wave functions on atomic wfc  

outdir         CHARACTER ( default =  value of the ESPRESSO_TMPDIR environment
               variable if set; current directory ('./') otherwise )
               input, temporary, trajectories and output files are found in 
               this directory.

disk_io        CHARACTER
               'high', 'default'
               'high'
                  CP code will write Kohn-Sham wf files and additional 
                  informations in data-file.xml in order to restart 
                  with a PW calculation or to use postprocessing tools.

saverho        LOGICAL 
               This flag controls the saving of charge density in CP codes:
               If  .TRUE.        save charge density to restart dir,
               If .FALSE. do not save charge density. 

pseudo_dir     CHARACTER ( default = value of the $ESPRESSO_PSEUDO environment
               variable if set; '$HOME/espresso/pseudo/' otherwise )
               directory containing pseudopotential files.

ndr, ndw       INTEGER ( default = 50 )
               Units for input and output restart file.

tabps          LOGICAL ( default = .false. )
               .true. to compute the volume and/or the surface of an isolated
               system for finete pressure/finite surface tension calculations
               (PRL 94, 145501 (2005); JCP 124, 074103 (2006)).
               


===============================================================================
NAMELIST &SYSTEM

ibrav          INTEGER
               bravais-lattice index (must be specified)
               see at the end of this file

celldm(i)      REAL, DIMENSION(6)                        
               crystallographic constants - see at the end of this file
               alat = celldm(1) is the lattice parameter "a" (in BOHR)
               only needed celldm (depending on ibrav) must be specified

a, b, c, cosab, cosac, cosbc: 
               REAL
	       traditional crystallographic constants (a,b,c in ANGSTROM)
               specify either these or celldm  but not both
 
nat            INTEGER
               number of atoms in the unit cell - must be specified

ntyp           INTEGER
               number of types of atoms in the unit cell - must be specified

ecutwfc        REAL
               kinetic energy cutoff (Ry) for wavefunctions
               (must be specified)
	       
ecutrho        REAL ( default = 4 * ecutwfc )
               kinetic energy cutoff (Ry) for charge density and potential
               May be larger ( for ultrasoft PP ) or somewhat smaller 
               ( but not much smaller ) than the default value. Note that
               if you have norm-conserving PP only, setting it to a larger
               value than the default is a waste of time.

nelec          INTEGER
               number of electron in the unit cell. If not specified it is
               read from the pseudopotential

tot_charge     INTEGER ( default = 0 )
               total system charge. Used only if nelec is unspecified,
               otherwise it is ignored.

nbnd           INTEGER ( default = nelec / 2 )
               number of electronic states (bands) to be calculated.

input_dft      CHARACTER ( default = read from pseudopotential files )
               forces the usage of a given XC functional, E.g.:
               'BLYP'  use Becke-Lee-Yang-Parr GCC-XC Functional
               'BP'    use Becke-Perdew GCC-XC Functionals
               'PBE'   use Perdew-Burke-Ernzerhof GCC-XC Functionals
               'PZ'    use Slater X, and Perdew-Zunger C Functionals
               'PW'    use Slater X, and Perdew-Wang C Functionals
               'LDA'   use LDA xc functional: the xc potential is
                       calculated through an interpolation table
                See Modules/functionals.f90 for a list of allowed values.
                Beware: replaces obsolete variable xc_type

occupations    CHARACTER
               a string describing the occupation of the electronic states.
               In the case of conjugate gradient style of minimization
               of the electronic states, if occupations is set to 'ensemble',  
               this allows ensemble DFT calculations for metallic systems 
                                                                                                                             
smearing       CHARACTER
               a string describing the kind of occupations for electronic states
               in the case of ensemble DFT (occupations == 'ensemble' );
               now only Fermi-Dirac ('fd') case is implemented
                                                                                                                             
degauss        REAL ( default = 0.D0 )
               parameter for the smearing function, only used for ensemble DFT
               calculations

nspin          INTEGER ( default = 1 )
               nspin = 1 :   non-polarized calculation
               nspin = 2 :  spin-polarized calculation

nelup, neldw   REAL
               number of spin-up and spin-down electrons, respectively.
               The sum must yield nelec that must also be specified
               explicitly in this case.

multiplicity   INTEGER ( default = 0 [unspecified] )
               spin multiplicity (2s+1). 1 is singlet, 2 for doublet etc.
               if unspecified or a non-zero value is specified in nelup/neldw
               then multiplicity variable is ignored.

tot_magnetization INTEGER ( default = -1 [unspecified] )
               majority spin - minority spin (nelup - neldw).
               if unspecified or a non-zero value is specified in nelup/neldw
               then tot_magnetization variable is ignored.
               YES, there is redundancy! nelup/neldw are enough to specify
               the spin state. However these variables are not very convenient
               and will be eliminated from the input in future versions.
	       It is recommended to use either 'multiplicity' or equivalently
               'tot_magnetization' to specify the spin state.

ecfixed        REAL ( default = 0.0 )
qcutz          REAL ( default = 0.0 )
q2sigma        REAL ( default = 0.1 )
               parameters for modified functional to be used in
               variable-cell molecular dynamics (or in stress calculation).
               "ecfixed" is the value (in Rydberg) of the constant-cutoff; 
               "qcutz" and "q2sigma" are the height and the width (in Rydberg) 
               of the energy step for reciprocal vectors whose square modulus 
               is greater than "ecfixed". In the kinetic energy, G^2 is
               replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) )
               See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995)
               Comment: For what would have been ecutwfc = 25.0 Ryd in fixed cell
               calculations one should use the following set of parameters for
               cell dynamics:
               (ecutwfc = 30.0, ecfixed = 25.0, qcutz = 25.0, q2sigma = 3.0)


nr1,nr2,nr3    INTEGER
               three-dimensional FFT mesh (hard grid) for charge
               density (and scf potential). If not specified
               the grid is calculated based on the cutoff for
               charge density (see also "ecutrho")

nr1s,nr2s,nr3s INTEGER
               three-dimensional mesh for wavefunction FFT and for the smooth 
               part of charge density ( smooth grid ). 
               Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )


nr1b, nr2b, nr3b 
               INTEGER
               dimensions of the "box" grid for Ultrasoft pseudopotentials
               must be specified if Ultrasoft PP are present



===============================================================================
NAMELIST &ELECTRONS

electron_maxstep  
               INTEGER ( default = 100 )
               maximum number of iterations in a scf step

electron_dynamics 
               CHARACTER ( default = 'none' )
               set how electrons should be moved
               none    = electronic degrees of freedom (d.o.f.) are kept fixed 
               sd      = steepest descent algorithm is used to minimize 
                         electronic d.o.f. 
               damp    = damped dynamics is used to propagate electronic d.o.f. 
               verlet  = standard Verlet algorithm is used to propagate 
                         electronic d.o.f. 
               cg      = conjugate gradient is used to converge the 
                         wavefunction at each ionic step. 'cg' can be used 
                         interchangeably with 'verlet' for a couple of ionic
                         steps in order to "cool down" the electrons and
                         return them back to the Born-Oppenheimer surface.
                         Then 'verlet' can be restarted again. This procedure 
                         is useful when electronic adiabaticity in CP is lost
                         yet the ionic velocities need to be preserved.

emass          REAL ( default = 400.D0 )
               effective electron mass in the CP Lagrangian, in atomic units 
               ( 1 a.u. of mass = 1/1822.9 a.m.u. = 9.10939 * 10^-31 kg )

emass_cutoff   REAL ( default = 2.5D0 )
               mass cut-off (in Rydberg) for the Fourier acceleration
               effective mass is rescaled for "G" vector components with 
               kinetic energy above "emass_cutoff" 

orthogonalization 
               CHARACTER ( default = 'ortho' )
               selects the orthonormalization method for electronic wave 
               functions
               ortho         = use iterative algorithm - if it doesn't converge, 
                               reduce the timestep, or use options ortho_max 
                               and ortho_eps, or use Gram-Schmidt instead just 
                               to start the simulation
               Gram-Schmidt  = use Gram-Schmidt algorithm - to be used ONLY in 
                               the first few steps. 
                               YIELDS INCORRECT ENERGIES AND EIGENVALUES.

ortho_eps      REAL ( default = 1.D-8 )
               tolerance for iterative orthonormalization
               meaningful only if orthogonalization = 'ortho'
            
ortho_max      INTEGER ( default = 20 )
               maximum number of iterations for orthonormalization
               meaningful only if orthogonalization = 'ortho'

ortho_para     INTEGER ( default = 0 )
               meaningful only if orthogonalization = 'ortho' and with parallel 
               executable.
               Suggested number of processors to be used for distributing
               lambda matrixes and for parallel diagonalization.
               With the default value ( 0 ) the code try to use the number 
               of processors, that gives the best performance
               OBSOLESCENT: use command-line option " -northo XX" instead

electron_damping 
               REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula :
                        SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1, E2, E3 are successive values of the DFT total energy 
               in a steepest descent simulations.
               meaningful only if " electron_dynamics = 'damp' "

electron_velocities
               CHARACTER
               zero      = restart setting electronic velocities to zero
               default   = restart using electronic velocities of the 
                           previous run

electron_temperature
               CHARACTER ( default = 'not_controlled' )
               nose            = control electronic temperature using Nose 
                                 thermostat. see parameter "fnosee" and "ekincw"
               rescaling       = control electronic temperature via velocities 
                                 rescaling 
               not_controlled  = electronic temperature is not controlled

ekincw         REAL ( default = 0.001D0 )
               value of the average kinetic energy (in atomic units) forced
               by the temperature control
               meaningful only with " electron_temperature /= 'not_controlled' "

fnosee         REAL ( default = 1.D0 )
               oscillation frequency of the nose thermostat (in terahertz) 
               meaningful only with " electron_temperature = 'nose' "

startingwfc    CHARACTER ( default = 'random' )
               random  = randomize electronic wave functions ( see "ampre" )
               atomic  = from superposition of atomic state 
                         (NOT YET IMPLEMENTED)

ampre          REAL ( default = 0.D0 )
               amplitude of the randomization ( allowed values: 0.0 - 1.0 )
               meaningful only if " startingwfc = 'random' "

grease         REAL ( default = 1.D0 )
               a number <= 1, very close to 1: the damping in electronic
               damped dynamics is multiplied at each time step by "grease"
               (avoids overdamping close to convergence: Obsolete ?)
               grease = 1 : normal damped dynamics

tcg            LOGICAL ( default = .FALSE. )
               if .TRUE. perform a conjugate gradient minimization of the
               electronic states for every ionic step.
               It requires Gram-Schmidt orthogonalization of the electronic
               states.

maxiter        INTEGER ( default = 100 )
               maximum number of conjugate gradient iterations for
               conjugate gradient minimizations of electronic states

conv_thr         REAL ( default = 1.D-6 )
               convergence criterion for energy in the case of
               conjugate gradient minimization of the electronic states
               
passop         REAL ( default =  0.3D0 )
               small step used in the  conjugate gradient minimization 
               of the electronic states. 

n_inner        INTEGER ( default = 2 )
               number of internal cycles for every conjugate gradient 
               iteration only for ensemble DFT

ninter_cold_restart INTEGER( default = 1) 
               frequency in iterations at which a full inner cycle, only
               for cold smearing, is performed

lambda_cold    REAL (default = 0.03d0)
               step for inner cycle with cold smearing, used when a not full
               cycle is performed
  
epol           INTEGER ( default = 3 )
               direction of the finite electric field (only if tefield == .TRUE.)
               In the case of a PARALLEL calculation only the case epol==3
               is implemented

efield         REAL ( default = 0.d0 )
               intensity in a.u. of the finite electric field 
               (only if tefield == .TRUE.)

niter_cg_restart INTEGER ( default = 20 )
               frequency in iterations for which the conjugate-gradient algorithm
               for electronic relaxation is restarted

===============================================================================
NAMELIST &IONS  ( only if calculation = 'cp', 'relax',
                                        'vc-relax', 'vc-cp', 'neb', 'smd' )

ion_dynamics   CHARACTER ( default = 'none' )
               set how ions should be moved
               none    = ions are kept fixed 
               sd      = steepest descent algorithm is used to minimize ionic 
                         configuration
               cg      = conjugate gradient algorithm is used to minimize ionic 
                         configuration
               damp    = damped dynamics is used to propagate ions
               verlet  = standard Verlet algorithm is used to propagate ions

ion_nstepe     INTEGER ( default = 1 )
               number of electronic steps per ionic step.

ion_radius(i)  REAL ( default = 0.5D0 )
               pseudo-atomic radius of the i-th atomic species for Ewald 
               summation (one for each atomic type). 
               values between 0.5 and 2.0 are usually used.

ion_damping    REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula:
                          SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1 E2 E3 are successive values of the DFT total energy 
               in a ionic steepest descent simulation.
               meaningful only if " ion_dynamics = 'damp' "

ion_positions  CHARACTER
               default     = restart the simulation with atomic positions read
                             from the restart file.
               from_input  = restart the simulation with atomic positions read
                             from standard input.
                             ( see also the card 'ATOMIC_POSITIONS' )

ion_velocities CHARACTER
               initial ionic velocities
               default     = restart the simulation with atomic velocities read
                             from the restart file
               change_step = restart the simulation with atomic velocities read
                             from the restart file, with rescaling due to the
                             timestep change, specify the old step via tolp
                             as in tolp = 'old_time_step_value' in au
               random      = start the simulation with random atomic velocities
               from_input  = restart the simulation with atomic velocities read
                             from standard input 
                             ( see the card 'ATOMIC_VELOCITIES' )
               zero        = restart the simulation with atomic velocities set 
                             to zero

ion_temperature  
               CHARACTER ( default = 'not_controlled' )
               nose            = control ionic temperature using Nose-Hoover
                                 thermostat  see parameters "fnosep", "tempw",
                                 "nhpcl", "ndega", "nhptyp"
               rescaling       = control ionic temperature via velocities 
                                 rescaling. see parameter "tolp"
               not_controlled  = ionic temperature is not controlled


tempw          REAL ( default = 300.D0 )
               value of the ionic temperature (in Kelvin) forced by the 
               temperature control.
               meaningful only with " ion_temperature /= 'not_controlled' "
               "ndega" controls number of degrees of freedom used in 
               temperature calculation

fnosep         REAL ( default = 1.0D0 )
               oscillation frequency of the nose thermostat (in terahertz)
               [note that 3 terahertz = 100 cm^-1]
               meaningful only with " ion_temperature = 'nose' "
               for Nose-Hoover chain one can set frequencies of all thermostats
               ( fnosep = X Y Z etc. ) If only first is set, the defaults for 
               the others will be same.

nhpcl          INTEGER ( default = 1 )
               number of thermostats in the Nose-Hoover chain
               currently maximum allowed is 4

nhptyp         INTEGER ( default = 0 )
               type of the "massive" Nose-Hoover chain thermostat
               nhptyp=1 uses a NH chain per each atomic type
               nhptyp=2 uses a NH chain per atom, this one is useful
               for extremely rapid equipartitioning (equilibration is a 
               different beast)
               nhptyp=3 together with nhgrp allows fine grained thermostat
               control
               NOTE: if using more than 1 thermostat per system there will
               be a common thermostat added on top of them all, to disable
               this common thermostat specify nhptyp=-X instead of nhptyp=X

nhgrp(i)       INTEGER ( default = 0 )
               specifies which thermostat group to use for given atomic type
               when >0 assigns all the atoms in this type to thermostat
               labeled nhgrp(i), when =0 each atom in the type gets its own
               thermostat. Finally, when <0, then this atomic type will have
               temperature "not controlled". Example: HCOOLi, with types H (1), C(2), O(3), Li(4); 
               setting nhgrp={2 2 0 -1} will add a common thermostat for both H & C,
               one thermostat per each O (2 in total), and a non-updated thermostat
               for Li which will effectively make temperature for Li "not controlled"

fnhscl(i)      REAL ( default = (Nat_{total}-1)/Nat_{total} )
               these are the scaling factors to be used together with nhptyp=3 and nhgrp(i)
               in order to take care of possible reduction in the degrees of freedom due to
               constraints. Suppose that with the previous example HCOOLi, C-H bond is
               constrained. Then, these 2 atoms will have 5 degrees of freedom in total instead
               of 6, and one can set fnhscl={5/6 5/6 1. 1.}. This way the target kinetic energy
               for H&C will become 6(kT/2)*5/6 = 5(kT/2). This option is to be used for
               simulations with many constraints, such as rigid water with something else in there

ndega          INTEGER ( default = 0 )
               number of degrees of freedom used for temperature calculation
               ndega <= 0 sets the number of degrees of freedom to 
               [3*nat-abs(ndega)], ndega > 0 is used as the target number

tolp           REAL ( default = 100.D0 )
               tolerance (in Kelvin) of the rescaling. When ionic temperature
               differs from "tempw" more than "tolp" apply rescaling.
               meaningful only with " ion_temperature = 'rescaling' "
               and with ion_velocities='change_step', where it specifies 
               the old timestep

tranp(i)       LOGICAL ( default = .FALSE. )
               If .TRUE. randomize ionic positions ( see "amprp" ) for the
               atomic type corresponding to the index i.

amprp(i)       REAL ( default = 0.D0 )
               amplitude of the randomization for the atomic type corresponding
               to the index i ( allowed values: 0.0 - 1.0 ).
               meaningful only if " tranp(i) = .TRUE.".

greasp         REAL ( default = 1.D0 )
               same as "grease", for ionic damped dynamics.

remove_rigid_rot
               LOGICAL ( default = .FALSE. )
               this keyword is useful when simulating the dynamics and/or the
               thermodynamics of an isolated system. If set to true the total
               torque of the internal forces is set to zero by adding new forces
               that compensate the spurious interaction with the periodic
               images. This allowes for the use of smaller supercells.
               BEWARE: since the potential energy is no longer consistent with
               the forces (it still contains the spurious interaction with the
               repeated images), the total energy is not conserved anymore.
               However the dynamical and thermodynamical properties should be
               in closer agreement with those of an isolated system.
               Also the final energy of a structural relaxation will be higher,
               but the relaxation itself should be faster.

!
! ... keywords used only in NEB calculations
!

num_of_images  INTEGER ( default = 0 )
               number of points used to discretize the path 
               (it must be larger than 3)

opt_scheme     
               CHARACTER ( default = "quick-min" )
               specify the type of optimization scheme      
               "sd"         : steepest descent
               "broyden"    : quasi-Newton Broyden's second method (suggested)
	       "quick-min"  : an optimisation algorithm based on the
	                      projected velovity Verlet scheme
               "langevin"   : finite temperature langevin dynamics of the 
                              string (smd only). It is used to compute the
                              average path and the free-energy profile.

CI_scheme      CHARACTER. ( default = "no-CI" )
               specify the type of Climbing Image scheme
               "no-CI"      : climbing image is not used
               "auto"       : original CI scheme. The image highest in energy 
	                      does not feel the effect of springs and is 
			      allowed to climb along the path
               "manual"     : images that have to climb are manually selected. 
	                      See also CLIMBING_IMAGES card

first_last_opt LOGICAL ( default = .FALSE. )
               also the first and the last configurations are optimised
               "on the fly" (these images do not feel the effect of the springs)

damp           REAL ( default = 1.D0 )
               Damping coefficient. Ignored when "opt_scheme" is different 
               from "damped-dyn"

temp_req       REAL ( default = 0.D0 Kelvin )
               temperature used for the langevin dynamics of the string.

ds             REAL ( default = 1.D0 )
               optimisation step length ( Hartree atomic units ).
               If opt_scheme="broyden" ds is used as a guess for the diagonal
               part of the Jacobian matrix.
	              
k_max, k_min   REAL ( default = 0.1D0 Hartree atomic units )
               set them to use a Variable Elastic Constants scheme 
	       elastic constants are in the range [ k_min, k_max ] 
	       this is useful to rise the resolution around the saddle point

path_thr       REAL ( default = 0.05D0 eV / Angstrom )
               the simulation stops when the error ( the norm of the force 
	       orthogonal to the path in eV/A ) is less than path_thr.

use_freezing   LOGICAL ( default = .FALSE. )
               if. TRUE. the images are optimised according to their error:
               only those images with an error larger than half of the largest
               are optimised. The other images are kept frozen.

!
! ... keywords used only in meta-dynamics calculations ( see also the card
! ... COLLECTIVE_VARS )
!

fe_step(i)     REAL ( default = 0.04 )
               meta-dynamics step length (in principle different for each
               collective variable), defined using the same units used 
               to define the collective variables themselves.
               The step also defines the spread of the Gaussian-like bias
               potential.

g_amplitude    REAL ( default = 0.005 Hartree )
               Amplitude of the gaussians used in meta-dynamics.

fe_nstep       INTEGER ( default = 100 )
               Maximum number of steps used to evaluate the potential of
               mean force.

sw_nstep       INTEGER ( default = 10 )
               Number of steps used to switch to the new values of the
               collective variables.

===============================================================================
NAMELIST &CELL ( only if calculation = 'vc-relax', 'vc-cp' )

cell_parameters  
               CHARACTER
               default      = restart the simulation with cell parameters read
                              from the restart file or "celldm" if 
                              "restart = 'from_scratch'"
               from_input   = restart the simulation with cell parameters
                              from standard input.
                              ( see the card 'CELL_PARAMETERS' )

cell_dynamics  CHARACTER ( default = 'none' )
               set how cell should be moved
               none      = cell is kept fixed 
               sd        = steepest descent algorithm is used to optimise the 
                           cell
               damp-pr   = damped dynamics is used to optimise the cell 
                           ( Parrinello-Rahman method ).
               pr        = standard Verlet algorithm is used to propagate 
                           the cell ( Parrinello-Rahman method ).

cell_damping 
               REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula :
                        SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1, E2, E3 are successive values of the DFT total energy 
               in a steepest descent simulations.
               meaningful only if " cell_dynamics = 'damp' "


cell_velocities
               CHARACTER
               zero      = restart setting cell velocity to zero
               default   = restart using cell velocity of the previous run

press          REAL ( default = 0.D0 )
               external pressure (in GPa: 1GPa = 10 kbar)

wmass          REAL ( default = 0.D0 )
               effective cell mass in the Parrinello-Rahman Lagrangian 
               (in atomic units) of the order of magnitude of the total atomic 
               mass (sum of the mass of the atoms) within the simulation cell.

cell_temperature  
               CHARACTER ( default = 'not_controlled )
               nose            = control cell temperature using Nose thermostat
                                 see parameters "fnoseh" and "temph".
               rescaling       = control cell temperature via velocities 
                                 rescaling.
               not_controlled  = cell temperature is not controlled.

temph          REAL ( default = 0.D0 )
               value of the cell temperature (in ???) forced
               by the temperature control.
               meaningful only with " cell_temperature /= 'not_controlled' "

fnoseh         REAL ( default = 1.D0 )
               oscillation frequency of the nose thermostat (in terahertz)
               meaningful only with " cell_temperature = 'nose' "

greash         REAL ( default = 1.D0 )
               same as "grease", for cell damped dynamics

cell_dofree    CHARACTER ( default = 'all' )
               select which of the cell parameters should be moved
               all     = all axis and angles are propagated
               volume  = the cell is simply rescaled, without changing the shape
               x       = only the x axis is moved
               y       = only the y axis is moved
               z       = only the z axis is moved
               xy      = only the x and y axis are moved, angles are unchanged
               xz      = only the x and z axis are moved, angles are unchanged
               yz      = only the y and z axis are moved, angles are unchanged
               xyz     = x, y and z axis are moved, angles are unchanged


===============================================================================
NAMELIST &PRESS_AI ( only if tabps = .true. )

abivol         LOGICAL ( default = .false. )
               .true. for finite pressure calculations

abisur         LOGICAL ( default = .false. )
               .true. for finite surface tension calculations

P_ext          REAL ( default = 0.d0 )
               external pressure in GPa

pvar           LOGICAL ( default = .false. )
               .true. for variable pressure calculations
               pressure changes linearly with time: 
               Delta_P = (P_fin - P_in)/nstep
        
P_in           REAL ( default = 0.d0 )
               only if pvar = .true.
               initial value of the external pressure (GPa)

P_fin          REAL ( default = 0.d0 )
               only if pvar = .true.
               final value of the external pressure (GPa)

Surf_t         REAL ( default = 0.d0 )
               Surface tension (in a.u.; typical values 1.d-4 - 1.d-3)

rho_thr        REAL ( default = 0.d0 )
               threshold parameter which defines the electronic charge density
               isosurface to compute the 'quantum' volume of the system
               (typical values: 1.d-4 - 1.d-3)
               (corresponds to alpha in PRL 94 145501 (2005))

dthr           REAL ( default = 0.d0 )
               thikness of the external skin of the electronic charge density
               used to compute the 'quantum' surface
               (typical values: 1.d-4 - 1.d-3; 50% to 100% of rho_thr)
               (corresponds to Delta in PRL 94 145501 (2005))

===============================================================================
NAMELIST &WANNIER ( only if calculation = 'cp-wf' )

wf_efield      LOGICAL ( default = .FALSE. )
               If dynamics will be done in the presence of a field          

wf_switch      LOGICAL ( default = .FALSE. )
               Whether to turn on the field adiabatically (adiabatic switch)
               if true, then nbeg is set to 0.				  

sw_len         INTEGER ( default = 1 )
               No. of iterations over which the field will be turned on     
               to its final value. Starting value is 0.0                     
               If sw_len < 0, then it is set to 1. 			  
	       If you want to just optimize structures on the presence of a 
	       field, then you may set this to 1 and run a regular geometry 
 	       optimization.						  

efx0 efy0 efz0 REAL ( default = 0.D0 )
               Initial values of the field along x, y, and z directions  

efx1 efy1 efz1 REAL ( default = 0.D0 )
               Final values of the field along x, y, and z directions   

wfsd           INTEGER ( default = 1 )
               Localization algorithm for Wannier function calculation:
               wfsd=1  Steepest-Descent / Conjugate-Gradient          
               wfsd=2  Damped Dynamics
               wfsd=3  Jocobi Rotation
               Remember, this is consistent with all the calwf options      
               as well as the tolw (see below).                            
               Not a good idea to Wannier dynamics with this if you are     
               using restart='from_scratch' option, since the spreads       
               converge fast in the beginning and ortho goes bananas.

wfdt           REAL ( default = 5.0D0 )
               The minimum step size to take in the SD/CG direction

maxwfdt        REAL ( default = 0.3D0 )
               The maximum step size to take in the SD/CG direction         
               The code calculates an optimum step size, but that may be    
               either too small (takes forever to converge)  or too large   
               (code goes crazy) . This option keeps the step size between  
               wfdt and maxwfdt. In my experience 0.1 and 0.5 work quite    
               well. (but don't blame me if it doesn't work for you           

nit            INTEGER ( default = 10 )
               Number of iterations to do for Wannier convergence.

nsd            INTEGER ( default = 10 )
               Out of a total of NIT iterations, NSD will be Steepest-Descent
               and ( nit - nsd ) will be Conjugate-Gradient.

wf_q	       REAL ( default = 1500.0D0 )
               Fictitious mass of the A matrix used for obtaining 	  
	       maximally localized Wannier functions. The unitary
	       transformation matrix U is written as exp(A) where 	  
	       A is a anti-hermitian matrix. The Damped-Dynamics is performed
	       in terms of the A matrix, and then U is computed from A.	  
	       Usually a value between 1500 and 2500 works fine, but should 
	       be tested.

wf_friction    REAL ( default = 0.3D0 )
               Damping coefficient for Damped-Dynamics.			  

nsteps         INTEGER ( default = 20 )
               Number of Damped-Dynamics steps to be performed per CP       
               iteration.

tolw           REAL ( default = 1.D-8 )
               Convergence criterion for localization.

adapt          LOGICAL ( default = .TRUE. )
               Whether to adapt the damping parameter dynamically.

calwf          INTEGER ( default = 3 )
               Wannier Function Options, can be 1,2,3,4,5
                                                                         
               1. Output the Wannier function density, nwf and wffort
                  are used for this option. see below.		          
               2. Output the Overlap matrix O_i,j=<w_i|exp{iGr}|w_j>. O is    
	          written to unit 38. For details on how O is constructed,    
                  see below.						  
               3. Perform nsteps of Wannier dynamics per CP iteration, the    
	          orbitals are now Wannier Functions, not Kohn-Sham orbitals. 
	          This is a Unitary transformation of the occupied subspace   
                  and does not leave the CP Lagrangian invariant. Expectation  
	          values remain the same. So you will **NOT** have a constant 
	          of motion during the run. Don't freak out, its normal.      
               4. This option starts for the KS states and does 1 CP iteration
                  and nsteps of Damped-Dynamics to generate  maximally         
 	          localized wannier functions. Its useful when you have the   
	          converged KS groundstate and want to get to the converged   
	          Wannier function groundstate in 1 CP Iteration.
               5. This option is similar to calwf 1, except that the output is
	          the Wannier function/wavefunction, and not the orbital      
                  density. See nwf below.
									  
nwf            INTEGER ( default = 0 )
               This option is used with calwf 1 and calwf 5. with calwf=1,  
	       it tells the code how many Orbital densities are to be       
 	       output. With calwf=5, set this to 1(i.e calwf=5 only writes  
	       one state during one run. so if you want 10 states, you have 
	       to run the code 10 times). With calwf=1, you can print many  
	       orbital densities in a single run.
               See also the PLOT_WANNIER card for specifying the states to 
               be printed.

wffort	       INTEGER ( default = 40 )
               This tells the code where to dump the orbital densities. Used
               only with CALWF=1. for e.g. if you want to print 2 orbital   
               densities, set calwf=1, nwf=2 and wffort to an appropriate   
               number (e.g. 40) then the first orbital density will be      
               output to fort.40, the second to fort.41 and so on. Note that
               in the current implementation, the following units are used  
               21,22,24,25,26,27,28,38,39,77,78 and whatever you define as  
               ndr and ndw. so use number other than these.                 

writev         LOGICAL ( default = .FALSE. )
               Output the charge density (g-space) and the list of g-vectors
               This is useful if you want to reconstruct the electrostatic  
               potential using the Poisson equation. If .TRUE. then the     
	       code will output the g-space charge density and the list     
               if G-vectors, and STOP.                                      
               Charge density is written to : CH_DEN_G_PARA.ispin (1 or 2   
               depending on the number of spin types) or CH_DEN_G_SERL.ispin
               depending on if the code is being run in parallel or serial  
               G-vectors are written to G_PARA or G_SERL.                   
                                                                         
Nota Bene 1:   For calwf = 5, wffort is not used. The 			  
	       Wannier/Wave(function) coefficients are written to unit 22 
	       and the corresponding g-vectors (basis vectors) are        
 	       written to unit 21. This option gives the g-vecs and       
	       their coeffs. in reciprocal space, and the coeffs. are     
               complex. You will have to convert them to real space       
               if you want to plot them for visualization. calwf=1 gives  
	       the orbital densities in real space, and this is usually   
               good enough for visualization.
									  
Output files used by Wannier Function options are the following

      fort.21: Used only when calwf=5, contains the full list of g-vecs. 
      fort.22: Used Only when calwf=5, contains the coeffs. corresponding
               to the g-vectors in fort.21				  
      fort.24: Used with calwf=3,contains the average spread 	          
      fort.25: Used with calwf=3, contains the individual Wannier        
               Function Spread of each state 		                  
      fort.26: Used with calwf=3, contains the wannier centers along a   
               trajectory.
      fort.27: Used with calwf=3 and 4,  contains some general runtime   
               information from ddyn, the subroutine that actually       
               does the localization of the orbitals.                    
      fort.28: Used only if efield=.TRUE. , contains the polarization    
               contribution to the total energy.			  
									  
Also, The center of mass is fixed during the Molecular Dynamics.        
									  
BEWARE : THIS WILL ONLY WORK IF THE NUMBER OF PROCESSORS IS LESS THAN OR
         EQUAL TO THE NUMBER OF STATES.                                 
                                                                         

===============================================================================
CARDS: { } = optional

-------------------------------------------------------------------------------

ATOMIC_SPECIES

Syntax:

ATOMIC_SPECIES
 X(1)     Mass_X(1)     PseudoPot_X(ntyp)
 X(2)     Mass_X(2)     PseudoPot_X(ntyp)
 ...
 X(ntyp)  Mass_X(ntyp)  PseudoPot_X(ntyp)

Description:
 X           CHARACTER : label of the atom
 Mass_X      REAL      : mass of the atomic species [amu: mass of C = 12]
                         not used if calculation='scf', 'nscf', 'phonon'
 PseudoPot_X CHARACTER:  file containing PP for this species

 The pseudopotential file is assumed to be in the new UPF format.
 If it doesn't work, the pseudopotential format is determined by
 the file name:
     *.vdb or *.van     Vanderbilt US pseudopotential code
     *.RRKJ3            Andrea Dal Corso's code (old format)
     none of the above  old PWscf norm-conserving format
 
-------------------------------------------------------------------------------

ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }

   alat    : atomic positions are in units of alat
   bohr    : atomic positions are in a.u. (default)
   crystal : atomic positions are in crystal coordinates (see below)
   angstrom: atomic positions are in A

- in all cases EXCEPT calculation = 'neb' or 'smd' :

  There are "nat" cards like the following
     X  x y z   {if_pos(1) if_pos(2) if_pos(3)}
  where :
    X         Character: label of the atom as specified in ATOMIC_SPECIES
    x, y, z   Real: atomic positions 
    if_pos:   Integer, optional ( default = 1 ): component i of the force for 
              this atom is multiplied by if_pos(i), which must be either 0 or 1.
              Used to keep selected atoms and/or selected components fixed in 
              meta-dynamics, neb, smd, MD dynamics or structural optimization
              run.

- if calculation = 'neb' .OR. 'smd'

  There are at least two groups of cards, each group composed by an identifier
  followed by "nat" cards as specified above:
     identifier
     X  x y z   {if_pos(1) if_pos(2) if_pos(3)}
  The first group ( identifier="first_image" ) contains the first image,
  the last group  ( identifier="last_image" )  contains the last image.
  There is also the possibility of specifying intermediate images; in this case
  their coordinates must be set between the first_image and the last_image.
  ( identifier="intermediate_image", followed by "nat" position cards ). 

  Image configurations must be specified in the following order:
  
  first_image                                           <= mandatory
   X 0.0  0.0  0.0  { if_pos(1) if_pos(2) if_pos(3) }
   Y 0.5  0.0  0.0  { if_pos(1) if_pos(2) if_pos(3) }
   Z 0.0  0.2  0.2  { if_pos(1) if_pos(2) if_pos(3) }
  intermediate_image 1                                  <= optional
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z 0.0  0.2  0.2
  intermediate_image ...                                <= optional
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z 0.0  0.2  0.2
  last_image                                            <= mandatory
   X 0.0  0.0  0.0
   Y 0.7  0.0  0.0
   Z 0.0  0.5  0.2  
   
  IMPORTANT: the total number of configurations specified in the input file 
             must be less than num_of_images (as specified in &IONS).
             The initial path is obtained interpolating between the specified
             configurations so that all images are equispaced (only the
             coordinates of the first and last images are not changed). 

-------------------------------------------------------------------------------

ATOMIC_VELOCITIES

  optional card :  reads velocities (in atomic units) from standard input
  
  Syntax:
  
   ATOMIC_VELOCITIES
     label(1)  Vx(1) Vy(1) Vz(1)
     ....
     label(n)  Vx(n) Vy(n) Vz(n)

  Where:
  
     label                     CHARACTER(LEN=4) atomic label
     Vx(:), Vy(:) and Vz(:)    REAL             x, y and z components of the 
                                                ionic velocities

  IMPORTANT:  when starting with ion_velocities="from_input" is convenient
              to perform few steps (~5-10) with a smaller time step (0.5 a.u.)

-------------------------------------------------------------------------------

CELL_PARAMETERS

  optional card, needed only if ibrav = 0 is specified

  Syntax:
  
    CELL_PARAMETERS
      a(1,1) a(2,1) a(3,1)
      a(1,2) a(2,2) a(3,2)
      a(1,3) a(2,3) a(3,3)

  a(:,1) = crystal axis 1    alat units   if celldm(1) was specified
      2                 2    a.u.         if celldm(1)=0
      3                 3

-------------------------------------------------------------------------------

CLIMBING_IMAGES

  optional card, needed only if calculation = 'neb' and CI_scheme = 'manual'
  
  Syntax:
  
   CLIMBING_IMAGES
     index1, index2, ..., indexN
  
  where index1, index2, ..., indexN are the indices of the images to which 
  apply the Climbing Image procedure. If more than an image is specified they
  must be separated by a comma
       
-------------------------------------------------------------------------------

CONSTRAINTS

   Ionic Constraints

 Syntax:

    CONSTRAINTS
      nconstr   { constr_tol }
      constr_type(.)  constr(1,.)  constr(2,.) ... { constr_target(.) }

 Where:

      nconstr     INTEGER, number of constraints
      constr_tol  REAL,    tolerance for keeping the constraints satisfied

      constr_type(.) CHARACTER, type of constrain :
      
        'type_coord'      : constraint on global coordination-number, i.e. the 
                            average number of atoms of type B surrounding the 
                            atoms of type A. The coordination is defined by
                            using a Fermi-Dirac.
                            (four indexes must be specified).
 
        'atom_coord'      : constraint on local coordination-number, i.e. the 
                            average number of atoms of type A surrounding a 
                            specific atom. The coordination is defined by
                            using a Fermi-Dirac.
                            (four indexes must be specified).
                            
        'distance'        : constraint on interatomic distance (two atom indexes
                            must be specified ).
 
        'planar_angle'    : constraint on planar angle (three atom indexes must
                            be specified).
 
        'torsional_angle' : constraint on torsional angle (four atom indexes 
                            must be specified).

        'bennett_proj'    : constraint on the projection onto a given direction
                            of the vector defined by the position of one atom 
                            minus the center of mass of the others.
                            ( Ch.H. Bennett in Diffusion in Solids, Recent
                              Developments, Ed. by A.S. Nowick and J.J. Burton,
                              New York 1975 ).

      constr(1,.) constr(2,.) ...  REAL,  these variables have different 
                                          meanings for different constraint
                                          types:
                           'type_coord' : constr(1) is the first index of the
                                          atomic type involved
                                          constr(2) is the second index of the
                                          atomic type involved
                                          constr(3) is the cut-off radius for
                                          estimating the coordination
                                          constr(4) is a smoothing parameter
                           'atom_coord' : constr(1) is the atom index of the
                                          atom with constrained coordination
                                          constr(2) is the index of the atomic
                                          type involved in the coordination
                                          constr(3) is the cut-off radius for
                                          estimating the coordination
                                          constr(4) is a smoothing parameter
                             'distance' : atoms indices object of the 
                                          constraint, as they appear in 
                                          the 'ATOMIC_POSITION' CARD
      'planar_angle', 'torsional_angle' : atoms indices object of the 
                                          constraint, as they appear in the 
                                          'ATOMIC_POSITION' CARD (beware the
                                          order)
                         'bennett_proj' : constr(1) is the index of the atom
                                          whose position is constrained.
                                          constr(2:4) are the three coordinates
                                          of the vector that specifies the
                                          constraint direction.

      constr_target               REAL,   target for the constrain ( angles are
                                          specified in degrees ).
                                          This variable is optional.

-------------------------------------------------------------------------------

COLLECTIVE_VARS

   Collective variables used for meta-dynamics calculations

 Syntax:

    COLLECTIVE_VARS
      ncolvars   { tolerance }
      colvar_type(.)  colvar(1,.)  colvar(2,.) ... 

 Where:

      ncolvars     INTEGER, number of collective variables
      tolerance    REAL,    tolerance used for SHAKE.

      colvar_type(.) CHARACTER, type of collective variable :

              ... see the definition of constr_type in the CONSTRAINTS card.

      colvar(1,.) colvar(2,.) ...  REAL,  these variables have different 
                                          meanings for different collective
                                          variable types. See the definition of
                                          constr in the CONSTRAINTS card.

-------------------------------------------------------------------------------

PLOT_WANNIER

  Indices of the states that have to be printed (only for calf=1 and calf=5).

 Syntax:

    PLOT_WANNIER
      iwf(1)  iwf(2) ...

 Where:


      iwf(:)   INTEGER
               These are the indices of the state that you want to output.  
	       Also used with calwf = 1 and 5. If calwf = 1, then you need 
               nwf indices here (each in a new line). If CALWF=5, then just 
               one index in needed.     					  


-------------------------------------------------------------------------------

  ibrav is the structure index:

    ibrav        structure                   celldm(2)-celldm(6)

      0          "free", see above                 not used
      1          cubic P (sc)                      not used
      2          cubic F (fcc)                     not used   
      3          cubic I (bcc)                     not used
      4          Hexagonal and Trigonal P        celldm(3)=c/a
      5          Trigonal R                      celldm(4)=cos(aalpha)
      6          Tetragonal P (st)               celldm(3)=c/a
      7          Tetragonal I (bct)              celldm(3)=c/a
      8          Orthorhombic P                  celldm(2)=b/a,celldm(3)=c/a
      9          Orthorhombic base-centered(bco) celldm(2)=b/a,celldm(3)=c/a
     10          Orthorhombic face-centered      celldm(2)=b/a,celldm(3)=c/a
     11          Orthorhombic body-centered      celldm(2)=b/a,celldm(3)=c/a
     12          Monoclinic P                    celldm(2)=b/a,celldm(3)=c/a,
                                                 celldm(4)=cos(ab)
     13          Monoclinic base-centered        celldm(2)=b/a,celldm(3)=c/a,
                                                 celldm(4)=cos(ab)
     14          Triclinic P                     celldm(2)= b/a,
                                                 celldm(3)= c/a,
                                                 celldm(4)= cos(bc),
                                                 celldm(5)= cos(ac),
                                                 celldm(6)= cos(ab)

  The special axis is the z-axis, one basal-plane vector is along x, 
  and the other basal-plane vector is at angle beta for monoclinic 
  (beta is not actually used), at 120 degrees for trigonal and hexagonal(p)
  groups, and at 90 degrees for remaining groups, excepted fcc, bcc, 
  tetragonal(i), for which the crystallographic vectors are as follows:

  fcc bravais lattice.
  ====================

  a1=(a/2)(-1,0,1), a2=(a/2)(0,1,1), a3=(a/2)(-1,1,0).

  bcc bravais lattice.
  ====================

  a1=(a/2)(1,1,1), a2=(a/2)(-1,1,1), a3=(a/2)(-1,-1,1).

  tetragonal (i) bravais lattices.
  ================================
  a1=(a/2,a/2,c/2), a2=(a/2,-a/2,c/2), a3=(-a/2,-a/2,c/2).

  trigonal(r) groups.
  ===================

  for these groups, the z-axis is chosen as the 3-fold axis, but the
  crystallographic vectors form a three-fold star around the z-axis,
  and the primitive cell is a simple rhombohedron. if c is the cosine
  of the angle between any pair of crystallographic vectors, and if
  tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3), the crystal-
  lographic vectors are:

        a1=a(0,2ty,tz),  a2=a(tx,-ty,tz),  a3=a(-tx,-ty,tz).

  bco base centered orthorhombic
  =============================
  a1=(a/2,b/2,0), a2=(-a/2,b/2,0), a3=(0,0,c)
-------------------------------------------------------------------------------



 ----------------------------------------------------------------------

 Description of the Additional input CARDS for FPMD code

 ----------------------------------------------------------------------

 SETNFI

   Reset the step counter to the specified value

 Syntax:

  SETNFI
     nfi

 Example:

  SETNFI
     100

 Where:

    nfi (integer) new value for the step counter

 ----------------------------------------------------------------

 VHMEAN

   Calculation of potential average along a given axis

 Syntax:

   VHMEAN
   unit nr rmin rmax asse

 Example:

   ????

 Where:

   ????

 ----------------------------------------------------------------

 DIPOLE

   calculate polarizability

 Syntax:

   DIPOLE

 Where:

    no parameters

 ----------------------------------------------------------------

 IESR

   use the specified number of neighbour cells for Ewald summations

 Syntax:

   ESR
    iesr

 Example:

   ESR
    3

 Where:

      iesr (integer)  determines the number of neighbour cells to be
                      considered:
                        iesr = 1 : nearest-neighbour cells (default)
                        iesr = 2 : next-to-nearest-neighbour cells
                        and so on

 ----------------------------------------------------------------

 NEIGHBOURS

   calculate the neighbours of (and the distance from) each atoms below the
   distance specified by the parameter

 Syntax:

   NEIGHBOURS
      cut_radius

 Example:

   NEIGHBOURS
      4.0

 Where:

      cut_radius ( real )  radius of the region where atoms are considered
                           as neighbours ( in a.u. )

 ----------------------------------------------------------------

 PSTAB

   calculate the pseudopotential form factor using an interpolation table

 Syntax:

    PSTAB
      pstab_size

 Example:

    PSTAB
    20000

 Where:

    pstab_size (integer) size of the interpolation table
                         typically values are between 10000 and 50000

 ----------------------------------------------------------------

 TURBO

   allocate space to store electronic states in real space while
   computing charge density, and then reuse the stored state
   in the calculation of forces instead of repeating the FFT

 Syntax:

    TURBO
      nturbo

 Example:

    TURBO
      64

 Where:

      nturbo (integer)  number of states to be stored

 ----------------------------------------------------------------

 KSOUT

   Enable the printing of Kohn Sham states

 Syntax ( nspin == 2 ):

   KSOUT
     nu
     iu(1) iu(2) iu(3) .. iu(nu)
     nd
     id(1) id(2) id(3) .. id(nd)

 Syntax ( nspin == 1 ):

   KSOUT
     ns
     is(1) is(2) is(3) .. is(ns)

 Example:

   ???

 Where:

   nu (integer)     number of spin=1 states to be printed
   iu(:) (integer)  indexes of spin=1 states, the state iu(k) is saved to file KS_UP.iu(k)
   nd (integer)     number of spin=2 states to be printed
   id(:) (integer)  indexes of spin=2 states, the state id(k) is saved to file KS_DW.id(k)

   ns (integer)     number of LDA states to be printed
   is(:) (integer)  indexes of LDA states, the state is(k) is saved to file KS.is(k)

 ----------------------------------------------------------------

 KSOUT_EMPTY

   Enable the printing of empty Kohn Sham states

 Syntax ( nspin == 2 ):

   KSOUT_EMPTY
     nu
     iu(1) iu(2) iu(3) .. iu(nu)
     nd
     id(1) id(2) id(3) .. id(nd)

 Syntax ( nspin == 1 ):

   KSOUT_EMPTY
     ns
     is(1) is(2) is(3) .. is(ns)

 Example:

   ???

 Where:

   nu (integer)     number of spin=1 empty states to be printed
   iu(:) (integer)  indexes of spin=1 empty states, the state iu(k)
                    is saved to file KS_EMP_UP.iu(k)
   nd (integer)     number of spin=2 empty states to be printed
   id(:) (integer)  indexes of spin=2 empty states, the state id(k)
                    is saved to file KS_EMP_DW.id(k)

   ns (integer)     number of LDA empty states to be printed
   is(:) (integer)  indexes of LDA empty states, the state is(k)
                    is saved to file KS_EMP.is(k)

 Note: the first empty state has index "1" !

 ----------------------------------------------------------------
